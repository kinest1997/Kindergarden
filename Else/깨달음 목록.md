# 깨달음 목록

## 1주차

### 2021-10-07
- 매번 viewdidload 안에 `self.view.addSubview.secondView` 이렇게 여러줄 추가하지않고 아래형식으로 하고 array 안에 구성요소만 넣어주면 해결된다
- 만약 이것말고도 여러개의 textfield의 delegate 선언을 할때도 이런식으로 하면 편함
```swift
  [secondView, topCenterLabel, addButton, subtractButton, newPageButton]
            .forEach {
                self.view.addSubview($0)
            }

```

-

### 2021-10-09
* 획득 목록은 클로저 내부에서 참조 타입을 획득하는 규칙을 제시할수있는 기능, 획득 목록은 클로저 내부의 매개변수 목록 이전 위치에 작성해줍니다 ( 이래서 _ 앞에 [weak self] 를 적는거고) 획득 목록은 참조방식(이게 weak)과 참조할 대상(이게 self)을 대괄호로 둘러싼 목록 형식으로 작성하며 획득목록 뒤에는 in 키워드를 사용해준다. 

- 이 방식을 사용하는 이유는 인스턴스가 메모리에서 해제되지않는 문제를 해결하기 위해서

- 그래서 위의 코드에서 약한참조를 안해주면 메모리에 계속 할당이되어 자원을 먹으니 약한참조로 바꿔주기 위해서 [weak self] 해주고 밑의 self 는 항상 존재하는게 아니라서 nil 값이 될수도있어서 self? 가 되는거고 하지만 실제로 실행시키면 값이 있으니까 크게 상관없는거고

```swift
let comeBack = UIAction { [weak self]_ in
            guard let hi = self?.delegate?.hiMaker(data: "강희성") else {
                return
            }
            print("\(hi)")
        }
​
let goodPrint = UIAction { _ in
            guard let alive = self.delegate?.hiMaker(data: "희수") else {
                return
            }
            print("\(alive)")
        }
```

-


### 2021-10-10
- xcode textField 에서 터치해도 키보드가 나오지 않을때
`command + 화살표 위 key(▲) + k `


## 2주차

### 2021-10-11
- `guard let self = self else { return }`
- 이렇게 하면 self? 를 안써도 되고 이쁨



- UIViewController 와 ViewController 는 다르다
- ViewController 는 UIViewController를 상속받는다는점을 기억하자.


```swift
let closureact = UIAction { [weak self]_ in
            guard let self = self else { return }
            let MVC = self.presentingViewController
            //presentingViewController = 현재 보고있는 뷰를 띄워준 뷰 즉 메인뷰
            //여기서 presentingViewController 는 UIViewcontroller 클래스로 MVC 의 타입을 넘겨주기때문에 우리가 만든 ViewController 로 주기위해선 다운캐스팅을 해줘야한다
            guard let vc = MVC as? ViewController else { return }
            //이렇게 다운캐스팅 해주면 비로소 viewController 클래스의 프로퍼티들에 접근 가능
            vc.secondText.text = self.textLabel.text
            self.dismiss(animated: true, completion: nil)
        }
```
### 2021-10-12
class,struct
- struct 는 객체의 주소값과 정보들이 전부다 stack 에 저장된다
- class 는 인스턴스를 생성할때 사용한 class 는 heap 에 저장되고 stack에는 그 heap 을 가리키는 주소값을 생성한다.
- 그 class로 생성된 인스턴스의 의 property 들도 heap 영역에 생성된다.
- class에서 stack 에 생성되는건 오로지 heap 을 가리키는 주소값 밖에없다. 이특성때문에 상속이 가능한거같다

- 상수와 변수의 개념 : 값을 저장할수있는 저장 공간
- 단순히 변할수 있는 것 변할수 없는 것 보다는 위의 개념이 명확한거 같다



### 2021-10-14
- 색을 정할떄 system 이 붙은 색을 고르면 다크모드설정시에 자동으로 그에맞는 반전된 색으로 변한다
- UIComponents 들은 tag 라는 index 비슷한 값을 가질수있다, 하지만 중복이 가능하고 다른건없는 꼬리표 같은존재
- UI컴포넌트들 메소드나 프로퍼티는 개발자 문서에 별 이상한 방법도 빠짐없이 다적혀있다. 
- 세그에 설정해논 이미지를 뽑아내는 그런 기이한 메소드까지있음 `func imageForSegment(at: Int) -> UIImage?
//Returns the image for a specific segment.` 



