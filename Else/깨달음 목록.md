# 깨달음 목록

## 1주차

### 2021-10-07
매번 viewdidload 안에 `self.view.addSubview.secondView` 이렇게 여러줄 추가하지않고 아래형식으로 하고 array 안에 구성요소만 넣어주면 해결된다

```swift
  [secondView, topCenterLabel, addButton, subtractButton, newPageButton]
            .forEach {
                self.view.addSubview($0)
            }

```

-

### 2021-10-09
* 획득 목록은 클로저 내부에서 참조 타입을 획득하는 규칙을 제시할수있는 기능, 획득 목록은 클로저 내부의 매개변수 목록 이전 위치에 작성해줍니다 ( 이래서 _ 앞에 [weak self] 를 적는거고) 획득 목록은 참조방식(이게 weak)과 참조할 대상(이게 self)을 대괄호로 둘러싼 목록 형식으로 작성하며 획득목록 뒤에는 in 키워드를 사용해준다. 

이 방식을 사용하는 이유는 인스턴스가 메모리에서 해제되지않는 문제를 해결하기 위해서

그래서 위의 코드에서 약한참조를 안해주면 메모리에 계속 할당이되어 자원을 먹으니 약한참조로 바꿔주기 위해서 [weak self] 해주고 밑의 self 는 항상 존재하는게 아니라서 nil 값이 될수도있어서 self? 가 되는거고 하지만 실제로 실행시키면 값이 있으니까 크게 상관없는거고

```swift
let comeBack = UIAction { [weak self]_ in
            guard let hi = self?.delegate?.hiMaker(data: "강희성") else {
                return
            }
            print("\(hi)")
        }
​
let goodPrint = UIAction { _ in
            guard let alive = self.delegate?.hiMaker(data: "희수") else {
                return
            }
            print("\(alive)")
        }
```

-


### 2021-10-10
xcode textField 에서 터치해도 키보드가 나오지 않을때
command + 화살표 위 key(▲) + k 


### 2021-10-11
guard let self = self else { return }
// 이렇게 하면 self? 를 안써도 되고 이쁨



UIViewController 와 ViewController 는 다르다
ViewController 는 UIViewController를 상속받는다는점을 기억하자.


```swift
let closureact = UIAction { [weak self]_ in
            guard let self = self else { return }
            let MVC = self.presentingViewController
            //presentingViewController = 현재 보고있는 뷰를 띄워준 뷰 즉 메인뷰
            //여기서 presentingViewController 는 UIViewcontroller 클래스로 MVC 의 타입을 넘겨주기때문에 우리가 만든 ViewController 로 주기위해선 다운캐스팅을 해줘야한다
            guard let vc = MVC as? ViewController else { return }
            // 이렇게 다운캐스팅 해주면 비로소 viewController 클래스의 프로퍼티들에 접근 가능
            vc.secondText.text = self.textLabel.text
            self.dismiss(animated: true, completion: nil)
        }
```